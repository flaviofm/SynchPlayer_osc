'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = queue;

var _onlyOnce = require('./onlyOnce.js');

var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

var _setImmediate = require('./setImmediate.js');

var _setImmediate2 = _interopRequireDefault(_setImmediate);

var _DoublyLinkedList = require('./DoublyLinkedList.js');

var _DoublyLinkedList2 = _interopRequireDefault(_DoublyLinkedList);

var _wrapAsync = require('./wrapAsync.js');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function queue(worker, concurrency, payload) {
  var _q;

  if (concurrency == null) {
    concurrency = 1;
  } else if (concurrency === 0) {
    throw new RangeError('Concurrency must not be zero');
  }

  var _worker = (0, _wrapAsync2["default"])(worker);

  var numRunning = 0;
  var _workersList = [];
  var events = {
    error: [],
    drain: [],
    saturated: [],
    unsaturated: [],
    empty: []
  };

  function on(event, handler) {
    events[event].push(handler);
  }

  function once(event, handler) {
    var handleAndRemove = function handleAndRemove() {
      off(event, handleAndRemove);
      handler.apply(void 0, arguments);
    };

    events[event].push(handleAndRemove);
  }

  function off(event, handler) {
    if (!event) return Object.keys(events).forEach(function (ev) {
      return events[ev] = [];
    });
    if (!handler) return events[event] = [];
    events[event] = events[event].filter(function (ev) {
      return ev !== handler;
    });
  }

  function trigger(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    events[event].forEach(function (handler) {
      return handler.apply(void 0, args);
    });
  }

  var processingScheduled = false;

  function _insert(data, insertAtFront, rejectOnError, callback) {
    if (callback != null && typeof callback !== 'function') {
      throw new Error('task callback must be a function');
    }

    q.started = true;
    var res, rej;

    function promiseCallback(err) {
      // we don't care about the error, let the global error handler
      // deal with it
      if (err) return rejectOnError ? rej(err) : res();

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      if (args.length <= 1) return res(args[0]);
      res(args);
    }

    var item = q._createTaskItem(data, rejectOnError ? promiseCallback : callback || promiseCallback);

    if (insertAtFront) {
      q._tasks.unshift(item);
    } else {
      q._tasks.push(item);
    }

    if (!processingScheduled) {
      processingScheduled = true;
      (0, _setImmediate2["default"])(function () {
        processingScheduled = false;
        q.process();
      });
    }

    if (rejectOnError || !callback) {
      return new Promise(function (resolve, reject) {
        res = resolve;
        rej = reject;
      });
    }
  }

  function _createCB(tasks) {
    return function (err) {
      numRunning -= 1;

      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      for (var i = 0, l = tasks.length; i < l; i++) {
        var task = tasks[i];

        var index = _workersList.indexOf(task);

        if (index === 0) {
          _workersList.shift();
        } else if (index > 0) {
          _workersList.splice(index, 1);
        }

        task.callback.apply(task, [err].concat(args));

        if (err != null) {
          trigger('error', err, task.data);
        }
      }

      if (numRunning <= q.concurrency - q.buffer) {
        trigger('unsaturated');
      }

      if (q.idle()) {
        trigger('drain');
      }

      q.process();
    };
  }

  function _maybeDrain(data) {
    if (data.length === 0 && q.idle()) {
      // call drain immediately if there are no tasks
      (0, _setImmediate2["default"])(function () {
        return trigger('drain');
      });
      return true;
    }

    return false;
  }

  var eventMethod = function eventMethod(name) {
    return function (handler) {
      if (!handler) {
        return new Promise(function (resolve, reject) {
          once(name, function (err, data) {
            if (err) return reject(err);
            resolve(data);
          });
        });
      }

      off(name);
      on(name, handler);
    };
  };

  var isProcessing = false;
  var q = (_q = {
    _tasks: new _DoublyLinkedList2["default"](),
    _createTaskItem: function _createTaskItem(data, callback) {
      return {
        data: data,
        callback: callback
      };
    }
  }, _defineProperty(_q, Symbol.iterator,
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee() {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(q._tasks[Symbol.iterator](), "t0", 1);

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })), _defineProperty(_q, "concurrency", concurrency), _defineProperty(_q, "payload", payload), _defineProperty(_q, "buffer", concurrency / 4), _defineProperty(_q, "started", false), _defineProperty(_q, "paused", false), _defineProperty(_q, "push", function push(data, callback) {
    if (Array.isArray(data)) {
      if (_maybeDrain(data)) return;
      return data.map(function (datum) {
        return _insert(datum, false, false, callback);
      });
    }

    return _insert(data, false, false, callback);
  }), _defineProperty(_q, "pushAsync", function pushAsync(data, callback) {
    if (Array.isArray(data)) {
      if (_maybeDrain(data)) return;
      return data.map(function (datum) {
        return _insert(datum, false, true, callback);
      });
    }

    return _insert(data, false, true, callback);
  }), _defineProperty(_q, "kill", function kill() {
    off();

    q._tasks.empty();
  }), _defineProperty(_q, "unshift", function unshift(data, callback) {
    if (Array.isArray(data)) {
      if (_maybeDrain(data)) return;
      return data.map(function (datum) {
        return _insert(datum, true, false, callback);
      });
    }

    return _insert(data, true, false, callback);
  }), _defineProperty(_q, "unshiftAsync", function unshiftAsync(data, callback) {
    if (Array.isArray(data)) {
      if (_maybeDrain(data)) return;
      return data.map(function (datum) {
        return _insert(datum, true, true, callback);
      });
    }

    return _insert(data, true, true, callback);
  }), _defineProperty(_q, "remove", function remove(testFn) {
    q._tasks.remove(testFn);
  }), _defineProperty(_q, "process", function process() {
    // Avoid trying to start too many processing operations. This can occur
    // when callbacks resolve synchronously (#1267).
    if (isProcessing) {
      return;
    }

    isProcessing = true;

    while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
      var tasks = [],
          data = [];
      var l = q._tasks.length;
      if (q.payload) l = Math.min(l, q.payload);

      for (var i = 0; i < l; i++) {
        var node = q._tasks.shift();

        tasks.push(node);

        _workersList.push(node);

        data.push(node.data);
      }

      numRunning += 1;

      if (q._tasks.length === 0) {
        trigger('empty');
      }

      if (numRunning === q.concurrency) {
        trigger('saturated');
      }

      var cb = (0, _onlyOnce2["default"])(_createCB(tasks));

      _worker(data, cb);
    }

    isProcessing = false;
  }), _defineProperty(_q, "length", function length() {
    return q._tasks.length;
  }), _defineProperty(_q, "running", function running() {
    return numRunning;
  }), _defineProperty(_q, "workersList", function workersList() {
    return _workersList;
  }), _defineProperty(_q, "idle", function idle() {
    return q._tasks.length + numRunning === 0;
  }), _defineProperty(_q, "pause", function pause() {
    q.paused = true;
  }), _defineProperty(_q, "resume", function resume() {
    if (q.paused === false) {
      return;
    }

    q.paused = false;
    (0, _setImmediate2["default"])(q.process);
  }), _q); // define these as fixed properties, so people get useful errors when updating

  Object.defineProperties(q, {
    saturated: {
      writable: false,
      value: eventMethod('saturated')
    },
    unsaturated: {
      writable: false,
      value: eventMethod('unsaturated')
    },
    empty: {
      writable: false,
      value: eventMethod('empty')
    },
    drain: {
      writable: false,
      value: eventMethod('drain')
    },
    error: {
      writable: false,
      value: eventMethod('error')
    }
  });
  return q;
}

module.exports = exports['default'];